#!/usr/local/bin/python

# Name: schemaSpyCleanup.py
# Purpose: to make MGI-specific customizations to the output HTML files
#	generated by schemaSpy.
# Notes: schemaSpy is a schema documentation generator hosted on SourceForge
#	and released under the lesser GPL license.  Since we are only altering
#	its output, rather than the source code itself, we will hopefully be
#	okay license-wise.

import os
import re
import sys
import getopt
import runCommand

USAGE='''Usage: %s [-a|-d|-i] <target file>
    Purpose:
	to make a few alterations to an HTML file generated by schemaSpy.
	Where possible, we always:
	  * improve the Indexes section for tables
	  * add MGI branding
	Relies upon PGDATABASE, PGHOST, PGPORT, and PGUSER being set properly,
	and upon the existence of a ~/.pgpass file corresponding to PGUSER.
    Options:
	-a : remove the "Anomalies" tab from the top of the page
	-d : remove the "Donate" tab from the top of the page
	-i : note that the file has no Index information, so do not give an
		error when none is found in the database
    Required Parameters:
	target file : the HTML file to edit and replace
''' % sys.argv[0]

###--- globals ---###

BRANDING = '''
<TABLE WIDTH="100%" BORDER=0 CELLPADDING=0 CELLSPACING=0>
 <TR>
  <TD WIDTH="100%" STYLE="background-color: #DFEFFF;">
   <TABLE WIDTH="100%" BORDER=0 CELLPADDING=0 CELLSPACING=0>
     <TR>
       <TD WIDTH="20%" STYLE="background-color: #DFEFFF;">
         <A HREF="http://www.informatics.jax.org/mgihome/homepages/"><IMG SRC="http://www.informatics.jax.org/webshare/images/mgi_logo.gif" BORDER="0"></A>
       </TD>
       <TD WIDTH="60%" STYLE="font-family:Arial, Helvetica; font-size:24px; text-align: center; background-color: #DFEFFF;">Schema Browser</TD>
       <TD width="20%" STYLE="background-color: #DFEFFF;"></TD>
     </TR>
     <TR STYLE="background-color: #DFEFFF;">
       <TD STYLE="background-color: #DFEFFF;">
	 <SPAN STYLE="font-size:10px; color:#002255;">
	   &nbsp;<A CLASS="logoFooter" HREF="http://www.informatics.jax.org/mgihome/homepages/" target="_top">Home</A>&nbsp;
	   |&nbsp;<A CLASS="logoFooter" HREF="http://www.informatics.jax.org/mgihome/projects/aboutmgi.shtml" target="_top">About</A>&nbsp;
	   |&nbsp;<A CLASS="logoFooter" HREF="http://www.informatics.jax.org/mgihome/homepages/help.shtml" target="_top">Help</A>&nbsp;
	   |&nbsp;<A CLASS="logoFooter" HREF="http://www.informatics.jax.org/faq/FAQ.shtml" TARGET="_top">FAQ</A>
	 </SPAN>
       </TD>
       <TD COLSPAN="2" STYLE="background-color: #DFEFFF;">&nbsp;</TD>
     </TR>
   </TABLE>
  </TD>
 </TR>
</TABLE>
'''

HOST = None
DATABASE = None
USER = None
PASSWORD = None
PATH = None
TABLE = None

STRIP_DONATE_TAB = False
STRIP_ANOMALIES_TAB = False
SKIP_INDEXES = False

###--- functions ---###

def bailout (message, showUsage = False):
	if showUsage:
		sys.stderr.write (USAGE)
	sys.stderr.write ('Error: %s\n' % message)
	sys.exit(1)

def processCommandLine():
	global HOST, DATABASE, USER, PASSWORD, PATH, TABLE
	global STRIP_DONATE_TAB, STRIP_ANOMALIES_TAB, SKIP_INDEXES

	try:
		(options, args) = getopt.getopt (sys.argv[1:], 'adi')
	except:
		bailout ('Invalid command-line')

	for (option, value) in options:
		if option == '-a':
			STRIP_ANOMALIES_TAB = True
		elif option == '-d':
			STRIP_DONATE_TAB = True
		elif option == '-i':
			SKIP_INDEXES = True
		else:
			bailout ('Unknown flag: %s' % option)

	if len(args) < 1:
		bailout ('Too few parameters')
	elif len(args) > 1:
		bailout ('Too many parameters')

	PATH = args[0]
	TABLE = os.path.basename(PATH).replace('.html', '')

	missing = []
	for var in [ 'PGDATABASE', 'PGHOST', 'PGUSER' ]:
		if not os.environ.has_key(var):
			missing.append (var)
	if missing:
		bailout ('Missing %d environment variable(s): %s' % (
			len(missing), ', '.join(missing)) )
	return

def analyzeColumns (columns):
	columns = map (lambda x : x.strip(), columns.split(',') )
	columnsOnly = []
	directions = []

	for column in columns:
		items = column.split()
		if (len(items) == 2) and (items[1] == 'DESC'):
		    col = items[0]
		    direction = 'Desc'
		else:
		    col = column
		    direction = 'Asc'

		# trim data types from function-based
		# columns
		col = re.sub('::[^)]+', '', col)

		columnsOnly.append (col)
		directions.append (direction)
	return columnsOnly, directions

q = re.compile('\((.*)\)$')
def analyzeCreateIndexStatement (line):
	global q
	
	match = q.search(line.strip())
	if match:
		columnsOnly, directions = analyzeColumns(match.group(1))
		return columnsOnly, directions

	return None

r = re.compile('"([^"]+)" ([^(]+)\((.+)\)')
def analyzeIndexLine (line):
	global r

	match =  r.match(line.strip())
	if match:
		name = match.group(1)
		attributes = match.group(2).rstrip().lower()
		columns = match.group(3)

		attributes = map (lambda x : x.strip().lower(),
			attributes.split(',') )
		columns = map (lambda x : x.strip(),
			columns.split(',') )

		if 'btree' in attributes:
			attributes.remove('btree')

		if 'unique' in attributes:
			attributes.remove('unique')
			attributes.append('Must be unique')

		if 'primary key' in attributes:
			attributes.remove('primary key')
			attributes.append('Primary key')

		if not attributes:
			attributes.append ('Performance')

		columnsOnly, directions = analyzeColumns(columns)

		return (name, attributes, columnsOnly, directions)
	return None

def getIndexDataSQL():
	# try to get the index data using direct SQL

	(stdout, stderr, exitCode) = runCommand.runCommand (
		"cat getIndexes.sql | sed 's/MY_TABLE_NAME/%s/' | psql" % TABLE)
	if exitCode:
		bailout ('psql failed with exit code %d, stderr: %s' % (
			exitCode, stderr))
	
	lines = stdout.split('\n')

	# skip the first two lines
	lines = lines[2:]

	# slice the lines into | delimited columns and trim whitespace
	#lines = map(lambda x : x.strip(), map(lambda y : y.split('|'), lines))

	newlines = []
	for line in lines:
		line = line.split('|')
		fields = []

		for field in line:
			fields.append (field.strip())
		newlines.append (fields)

	# columns:
	# 0. index name
	# 1. is primary key?
	# 2. is it unique?
	# 3. is the table clustered by this index?
	# 4. <skip>
	# 5. text of create index command
	# 6. constraint definition
	# 7-10. <skip>

	indexes = []
	for line in newlines:
		attributes = []

		if len(line) < 8:
			continue

		name = line[0]
		isPrimary = line[1]
		isUnique = line[2]
		isClustered = line[3]
		sql = line[5].lower()
		constraint = line[7]

		out = analyzeCreateIndexStatement(sql)

		if not out:
			continue
		columnsOnly, directions = out

		if isPrimary == 't':
			attributes.append ('Primary key')
		elif isUnique == 't':
			attributes.append ('Must be unique')
		else:
			attributes.append ('Performance')

		indexes.append ( (name, attributes, columnsOnly, directions) )

	return indexes

def getIndexData():
	# try to get the index data using the '\d' shortcut in psql

	if SKIP_INDEXES:
		return []

	(stdout, stderr, exitCode) = runCommand.runCommand (
		"psql -c '\d %s'" % TABLE)
	if exitCode:
		return getIndexDataSQL()

	lines = stdout.split('\n')

	indexes = []

	inIndexes = False
	for line in lines:
		if not inIndexes:
			if line.startswith('Indexes:'):
				inIndexes = True
		elif line.startswith('Foreign-key constraints:'):
			inIndexes = False
			break
		else:
			out = analyzeIndexLine(line)

			if out:
				indexes.append (out)
	return indexes

def readFile():
	fp = open(PATH, 'r')
	lines = fp.readlines()
	fp.close()
	return lines

def cleanup(lines):
	indexes = getIndexData()

	cleanLines = []

	beforeBranding = 0	# before we've added MGI branding
	beforeIndexes = 1	# before we get to the Indexes section
	beforeRows = 2		# before we find the data rows for Indexes
	inRows = 3		# while we are in the data rows for Indexes
	afterIndexes = 4	# after we've done the Indexes section

	status = beforeBranding

	for line in lines:
		if STRIP_DONATE_TAB:
			if line.find('>Donate<') >= 0:
				if line.find('sourceforge') >= 0:
					# skip the Donate tab
					continue

		if STRIP_ANOMALIES_TAB:
			if line.find('>Anomalies<') >= 0:
				if line.find('anomalies.html') >= 0:
					# skip the Anomalies tab
					continue

		if status == beforeBranding:
			if line.find('headerHolder') >= 0:
				# add branding and begin looking for the
				# Indexes section
				cleanLines.append (BRANDING)
				status = beforeIndexes

		elif status == beforeIndexes:
			if line.find('>Indexes:<') >= 0:
				# note that we've hit the start of the
				# Indexes section
				status = beforeRows

		elif status == beforeRows:
			if line.find('<tbody>') >= 0:
				# note that we have found the start of the
				# data rows of the Indexes section
				status = inRows

		elif status == inRows:
			if line.find('</table>') >= 0:
				status = afterIndexes

				# add in our custom data rows for the Indexes
				# table

				for (name, attr, cols, dirs) in indexes:
					if 'Primary key' in attr:
						class1 = 'primaryKey'
					else:
						class1 = 'indexedColumn'

					cell3 = []
					for dir in dirs:
						if dir == 'Asc':
							full = 'Ascending'
						else:
							full = 'Descending'

						cell3.append ("<span title='%s'>%s</span>" % (full, dir))

					cleanLines.append (" <tr>\n")
					cleanLines.append ("  <td class='%s'>%s</td>\n" % (class1, ' + '.join (cols)) )
					cleanLines.append ("  <td class='detail'>%s</td>\n" % ', '.join (attr))
					cleanLines.append ("  <td class='detail' style='text-align:left;'>%s</td>\n" % '/'.join(cell3))
					cleanLines.append ("  <td class='constraint' style='text-align:left;'>%s</td>\n" % name)
					cleanLines.append (" </tr>")

			else:
				# skip all data rows for the Indexes table, as
				# we are going to replace them
				continue

		cleanLines.append (line)
	return cleanLines

def writeFile (lines):
	fp = open (PATH, 'w')
	for line in lines:
		fp.write(line)
	fp.close()
	return

def main():
	processCommandLine()
	lines = cleanup(readFile())
	writeFile (lines)
	return

###--- main program ---###

if __name__ == '__main__':
	main()
